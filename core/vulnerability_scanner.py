"""
Vulnerability Scanner
Detects security vulnerabilities using various testing techniques
"""

import re
import time
from typing import Dict, List, Optional
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
from utils.logger import get_logger
from modules.api_security import APISecurityTester, GraphQLTester
from modules.business_logic import BusinessLogicTester
from modules.authentication import AuthenticationTester
from modules.file_upload import FileUploadTester
from modules.websocket import WebSocketTester
from modules.ml_detection import AnomalyDetector
from modules.payload_obfuscation import PayloadObfuscator

logger = get_logger(__name__)


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner with 45+ attack methods."""
    
    def __init__(self, config: Dict, http_client):
        """Initialize the vulnerability scanner."""
        self.config = config
        self.http_client = http_client
        self.scanner_config = config.get('vulnerability_scanner', {})
        self.enabled_checks = self.scanner_config.get('enabled_checks', [])
        
        # Initialize v1.1.0 security testing modules
        self.api_tester = APISecurityTester(http_client, config)
        self.graphql_tester = GraphQLTester(http_client)
        self.business_logic_tester = BusinessLogicTester(http_client, config)
        self.auth_tester = AuthenticationTester(http_client, config)
        self.file_upload_tester = FileUploadTester(http_client, config)
        
        # Initialize v1.2.0 advanced modules
        self.websocket_tester = WebSocketTester(http_client, config)
        self.anomaly_detector = AnomalyDetector(config)
        self.payload_obfuscator = PayloadObfuscator(config)
        
    def scan(self, url: str, payloads: Dict[str, List[str]], context: Dict, state_manager=None) -> List[Dict]:
        """
        Scan URL for vulnerabilities.
        
        Args:
            url: Target URL
            payloads: Generated payloads for different attack types
            context: Additional context information
            state_manager: Optional pentest state manager for tracking
            
        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []
        
        # Run enabled checks
        if 'sql_injection' in self.enabled_checks:
            if state_manager:
                state_manager.start_attack('sql_injection', url)
            vulns = self._check_sql_injection(url, payloads.get('sql_injection', []))
            vulnerabilities.extend(vulns)
            if state_manager:
                state_manager.end_attack(len(vulns) > 0, f"Found {len(vulns)} SQLi vulnerabilities")
        
        if 'xss' in self.enabled_checks:
            if state_manager:
                state_manager.start_attack('xss', url)
            vulns = self._check_xss(url, payloads.get('xss', []))
            vulnerabilities.extend(vulns)
            if state_manager:
                state_manager.end_attack(len(vulns) > 0, f"Found {len(vulns)} XSS vulnerabilities")
        
        if 'command_injection' in self.enabled_checks:
            if state_manager:
                state_manager.start_attack('command_injection', url)
            vulns = self._check_command_injection(url, payloads.get('command_injection', []))
            vulnerabilities.extend(vulns)
            if state_manager:
                state_manager.end_attack(len(vulns) > 0, f"Found {len(vulns)} command injection vulnerabilities")
        
        if 'ssrf' in self.enabled_checks:
            vulnerabilities.extend(self._check_ssrf(url, payloads.get('ssrf', [])))
        
        if 'xxe' in self.enabled_checks:
            vulnerabilities.extend(self._check_xxe(url, payloads.get('xxe', [])))
        
        if 'path_traversal' in self.enabled_checks:
            vulnerabilities.extend(self._check_path_traversal(url, payloads.get('path_traversal', [])))
        
        if 'csrf' in self.enabled_checks:
            vulnerabilities.extend(self._check_csrf(url, context))
        
        if 'open_redirect' in self.enabled_checks:
            vulnerabilities.extend(self._check_open_redirect(url))
        
        if 'cors_misconfiguration' in self.enabled_checks:
            vulnerabilities.extend(self._check_cors(url))
        
        if 'security_misconfiguration' in self.enabled_checks:
            vulnerabilities.extend(self._check_security_headers(url))
        
        # Additional vulnerability checks
        if 'lfi' in self.enabled_checks:
            vulnerabilities.extend(self._check_lfi(url, payloads.get('lfi', [])))
        
        if 'rfi' in self.enabled_checks:
            vulnerabilities.extend(self._check_rfi(url, payloads.get('rfi', [])))
        
        if 'ssti' in self.enabled_checks:
            vulnerabilities.extend(self._check_ssti(url, payloads.get('ssti', [])))
        
        if 'crlf_injection' in self.enabled_checks:
            vulnerabilities.extend(self._check_crlf_injection(url))
        
        if 'host_header_injection' in self.enabled_checks:
            vulnerabilities.extend(self._check_host_header_injection(url))
        
        if 'ldap_injection' in self.enabled_checks:
            vulnerabilities.extend(self._check_ldap_injection(url, payloads.get('ldap_injection', [])))
        
        if 'xml_injection' in self.enabled_checks:
            vulnerabilities.extend(self._check_xml_injection(url, payloads.get('xml_injection', [])))
        
        if 'insecure_deserialization' in self.enabled_checks:
            vulnerabilities.extend(self._check_insecure_deserialization(url))
        
        if 'authentication_bypass' in self.enabled_checks:
            vulnerabilities.extend(self._check_authentication_bypass(url, context))
        
        if 'information_disclosure' in self.enabled_checks:
            vulnerabilities.extend(self._check_information_disclosure(url, context))
        
        if 'sensitive_data_exposure' in self.enabled_checks:
            vulnerabilities.extend(self._check_sensitive_data_exposure(url, context))
        
        if 'jwt_vulnerabilities' in self.enabled_checks:
            vulnerabilities.extend(self._check_jwt_vulnerabilities(url, context))
        
        if 'broken_authentication' in self.enabled_checks:
            vulnerabilities.extend(self._check_broken_authentication(url, context))
        
        # New advanced security checks
        if 'api_security' in self.enabled_checks:
            if self._is_api_endpoint(url):
                vulnerabilities.extend(self.api_tester.test_api_endpoint(url, context))
        
        if 'graphql_security' in self.enabled_checks:
            if 'graphql' in url.lower():
                vulnerabilities.extend(self.graphql_tester.test_graphql_endpoint(url))
        
        # Aliases for backward compatibility
        if 'api_vulnerabilities' in self.enabled_checks:
            if self._is_api_endpoint(url):
                vulnerabilities.extend(self.api_tester.test_api_endpoint(url, context))
        
        if 'graphql_vulnerabilities' in self.enabled_checks:
            if 'graphql' in url.lower():
                vulnerabilities.extend(self.graphql_tester.test_graphql_endpoint(url))
        
        if 'business_logic' in self.enabled_checks:
            vulnerabilities.extend(self.business_logic_tester.test_business_logic(url, context))
        
        if 'authentication' in self.enabled_checks:
            vulnerabilities.extend(self.auth_tester.test_authentication(url, context))
        
        if 'file_upload' in self.enabled_checks:
            if self._is_upload_endpoint(url, context):
                vulnerabilities.extend(self.file_upload_tester.test_file_upload(url, context))
        
        # v1.2.0 Advanced security checks
        if 'websocket' in self.enabled_checks:
            ws_endpoints = self.websocket_tester.detect_websocket_endpoints(url, context.get('html_content', ''))
            for ws_url in ws_endpoints:
                vulnerabilities.extend(self.websocket_tester.test(ws_url))
        
        # Note: OSINT gathering has been moved to reconnaissance phase
        # Use context.get('osint_data') to access OSINT data gathered during recon
        
        if 'anomaly_detector' in self.enabled_checks:
            # Analyze individual response for anomalies
            anomalies = self.anomaly_detector.detect_anomalies(context.get('response', {}))
            vulnerabilities.extend(anomalies)
        
        # Apply payload obfuscation if enabled
        if self.scanner_config.get('use_payload_obfuscation', False):
            obfuscated_payloads = {}
            for attack_type, payload_list in payloads.items():
                obfuscated_payloads[attack_type] = [
                    self.payload_obfuscator.obfuscate_payload(p, attack_type)
                    for p in payload_list[:3]  # Obfuscate first 3 payloads
                ]
            # Re-run checks with obfuscated payloads
            if 'sql_injection' in self.enabled_checks:
                vulnerabilities.extend(self._check_sql_injection(url, obfuscated_payloads.get('sql_injection', [])))
            if 'xss' in self.enabled_checks:
                vulnerabilities.extend(self._check_xss(url, obfuscated_payloads.get('xss', [])))
        
        return vulnerabilities
    
    def _check_sql_injection(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for SQL injection vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        # SQL error patterns
        sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"ODBC SQL Server Driver",
            r"SQLServer JDBC Driver",
            r"Oracle error",
            r"PostgreSQL.*ERROR",
            r"Warning.*pg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"PG::SyntaxError:",
            r"SQLite/JDBCDriver",
            r"SQLite.Exception",
            r"System.Data.SQLite.SQLiteException",
        ]
        
        for param_name in params.keys():
            for payload in payloads[:5]:  # Test first 5 payloads per parameter
                # Inject payload into parameter
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                # Build test URL
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if not response:
                        continue
                    
                    # Check for SQL errors
                    for error_pattern in sql_errors:
                        if re.search(error_pattern, response.text, re.IGNORECASE):
                            vulnerabilities.append({
                                'type': 'SQL Injection',
                                'severity': 'critical',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'evidence': f"SQL error pattern detected: {error_pattern}",
                                'description': 'SQL injection vulnerability allows attackers to manipulate database queries',
                                'remediation': 'Use parameterized queries or prepared statements'
                            })
                            break
                    
                    # Time-based blind SQL injection
                    if 'SLEEP' in payload or 'BENCHMARK' in payload:
                        start_time = time.time()
                        response = self.http_client.get(test_url)
                        elapsed = time.time() - start_time
                        
                        if elapsed > 5:  # If response took more than 5 seconds
                            vulnerabilities.append({
                                'type': 'Time-Based Blind SQL Injection',
                                'severity': 'high',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'evidence': f'Response delayed by {elapsed:.2f} seconds',
                                'description': 'Time-based blind SQL injection detected',
                                'remediation': 'Use parameterized queries or prepared statements'
                            })
                
                except Exception as e:
                    logger.debug(f"Error testing SQL injection on {url}: {e}")
        
        return vulnerabilities
    
    def _check_xss(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for XSS vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        for param_name in params.keys():
            for payload in payloads[:5]:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if not response:
                        continue
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        vulnerabilities.append({
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'high',
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'evidence': 'Payload reflected in response',
                            'description': 'XSS vulnerability allows attackers to inject malicious scripts',
                            'remediation': 'Implement proper input validation and output encoding'
                        })
                        break
                
                except Exception as e:
                    logger.debug(f"Error testing XSS on {url}: {e}")
        
        return vulnerabilities
    
    def _check_command_injection(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for command injection vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        # Command injection indicators
        indicators = [
            'root:x:0:0',  # /etc/passwd
            'nobody:x:65534',
            '[boot loader]',  # boot.ini
            'www-data',
            'uid=',
            'gid=',
        ]
        
        for param_name in params.keys():
            for payload in payloads[:3]:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    # Test for time-based command injection
                    if 'sleep' in payload.lower():
                        start_time = time.time()
                        response = self.http_client.get(test_url)
                        elapsed = time.time() - start_time
                        
                        if elapsed > 5:
                            vulnerabilities.append({
                                'type': 'Command Injection',
                                'severity': 'critical',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'evidence': f'Response delayed by {elapsed:.2f} seconds',
                                'description': 'Command injection allows arbitrary command execution',
                                'remediation': 'Avoid executing system commands with user input'
                            })
                    else:
                        response = self.http_client.get(test_url)
                        if response:
                            for indicator in indicators:
                                if indicator in response.text:
                                    vulnerabilities.append({
                                        'type': 'Command Injection',
                                        'severity': 'critical',
                                        'url': url,
                                        'parameter': param_name,
                                        'payload': payload,
                                        'evidence': f'Command output indicator found: {indicator}',
                                        'description': 'Command injection allows arbitrary command execution',
                                        'remediation': 'Avoid executing system commands with user input'
                                    })
                                    break
                
                except Exception as e:
                    logger.debug(f"Error testing command injection on {url}: {e}")
        
        return vulnerabilities
    
    def _check_ssrf(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for SSRF vulnerabilities."""
        vulnerabilities = []
        # SSRF detection would require callback server
        # Placeholder implementation
        return vulnerabilities
    
    def _check_xxe(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for XXE vulnerabilities."""
        vulnerabilities = []
        
        for payload in payloads[:2]:
            try:
                response = self.http_client.post(
                    url,
                    data=payload,
                    headers={'Content-Type': 'application/xml'}
                )
                
                if response and ('root:x:0:0' in response.text or 'www-data' in response.text):
                    vulnerabilities.append({
                        'type': 'XML External Entity (XXE)',
                        'severity': 'high',
                        'url': url,
                        'payload': payload,
                        'evidence': 'File content disclosed in response',
                        'description': 'XXE vulnerability allows reading local files',
                        'remediation': 'Disable external entity processing in XML parsers'
                    })
            
            except Exception as e:
                logger.debug(f"Error testing XXE on {url}: {e}")
        
        return vulnerabilities
    
    def _check_path_traversal(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for path traversal vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        indicators = ['root:x:0:0', '[fonts]', '[extensions]', 'www-data']
        
        for param_name in params.keys():
            for payload in payloads[:3]:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if response:
                        for indicator in indicators:
                            if indicator in response.text:
                                vulnerabilities.append({
                                    'type': 'Path Traversal',
                                    'severity': 'high',
                                    'url': url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'evidence': f'File content indicator found: {indicator}',
                                    'description': 'Path traversal allows accessing files outside web root',
                                    'remediation': 'Validate and sanitize file paths, use whitelisting'
                                })
                                break
                
                except Exception as e:
                    logger.debug(f"Error testing path traversal on {url}: {e}")
        
        return vulnerabilities
    
    def _check_csrf(self, url: str, context: Dict) -> List[Dict]:
        """Check for CSRF vulnerabilities."""
        vulnerabilities = []
        
        try:
            response = self.http_client.get(url)
            if not response:
                return vulnerabilities
            
            # Check for CSRF token in forms
            if '<form' in response.text.lower():
                if not any(token in response.text.lower() for token in ['csrf', 'token', '_token', 'authenticity_token']):
                    vulnerabilities.append({
                        'type': 'Cross-Site Request Forgery (CSRF)',
                        'severity': 'medium',
                        'url': url,
                        'evidence': 'Form found without CSRF token',
                        'description': 'Missing CSRF protection on forms',
                        'remediation': 'Implement CSRF tokens for all state-changing operations'
                    })
        
        except Exception as e:
            logger.debug(f"Error checking CSRF on {url}: {e}")
        
        return vulnerabilities
    
    def _check_open_redirect(self, url: str) -> List[Dict]:
        """Check for open redirect vulnerabilities."""
        vulnerabilities = []
        redirect_payloads = ['http://evil.com', 'https://evil.com', '//evil.com']
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        redirect_params = ['url', 'redirect', 'next', 'return', 'ReturnUrl', 'redirect_uri']
        
        for param_name in params.keys():
            if any(rp in param_name.lower() for rp in redirect_params):
                for payload in redirect_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    test_query = urlencode(test_params, doseq=True)
                    test_url = urlunparse((
                        parsed.scheme,
                        parsed.netloc,
                        parsed.path,
                        parsed.params,
                        test_query,
                        parsed.fragment
                    ))
                    
                    try:
                        response = self.http_client.get(test_url, allow_redirects=False)
                        if response and response.status_code in [301, 302, 303, 307, 308]:
                            location = response.headers.get('Location', '')
                            if 'evil.com' in location:
                                vulnerabilities.append({
                                    'type': 'Open Redirect',
                                    'severity': 'medium',
                                    'url': url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'evidence': f'Redirects to: {location}',
                                    'description': 'Open redirect can be used in phishing attacks',
                                    'remediation': 'Validate redirect URLs against whitelist'
                                })
                                break
                    
                    except Exception as e:
                        logger.debug(f"Error testing open redirect on {url}: {e}")
        
        return vulnerabilities
    
    def _check_cors(self, url: str) -> List[Dict]:
        """Check for CORS misconfigurations."""
        vulnerabilities = []
        
        try:
            headers = {'Origin': 'http://evil.com'}
            response = self.http_client.get(url, headers=headers)
            
            if response:
                acao = response.headers.get('Access-Control-Allow-Origin', '')
                if acao == 'http://evil.com' or acao == '*':
                    vulnerabilities.append({
                        'type': 'CORS Misconfiguration',
                        'severity': 'medium',
                        'url': url,
                        'evidence': f'Access-Control-Allow-Origin: {acao}',
                        'description': 'Overly permissive CORS policy',
                        'remediation': 'Restrict CORS to trusted origins only'
                    })
        
        except Exception as e:
            logger.debug(f"Error checking CORS on {url}: {e}")
        
        return vulnerabilities
    
    def _check_security_headers(self, url: str) -> List[Dict]:
        """Check for missing security headers."""
        vulnerabilities = []
        
        try:
            response = self.http_client.get(url)
            if not response:
                return vulnerabilities
            
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-Content-Type-Options': 'MIME sniffing protection missing',
                'Strict-Transport-Security': 'HSTS not enforced',
                'Content-Security-Policy': 'CSP not implemented',
                'X-XSS-Protection': 'XSS protection header missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'Security Misconfiguration',
                        'severity': 'low',
                        'url': url,
                        'evidence': f'Missing header: {header}',
                        'description': description,
                        'remediation': f'Add {header} header to all responses'
                    })
        
        except Exception as e:
            logger.debug(f"Error checking security headers on {url}: {e}")
        
        return vulnerabilities
    
    def _check_lfi(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for Local File Inclusion vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        # LFI indicators
        lfi_indicators = [
            'root:x:0:0',
            '[boot loader]',
            'www-data',
            '[extensions]',
            'for 16-bit app support',
            'WINDIR='
        ]
        
        # Default payloads if none provided
        if not payloads:
            payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\win.ini',
                '....//....//....//etc/passwd',
                '..%2F..%2F..%2Fetc%2Fpasswd',
                '/etc/passwd',
                'C:\\windows\\win.ini'
            ]
        
        for param_name in params.keys():
            for payload in payloads[:5]:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if response:
                        for indicator in lfi_indicators:
                            if indicator in response.text:
                                vulnerabilities.append({
                                    'type': 'Local File Inclusion (LFI)',
                                    'severity': 'high',
                                    'url': url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'evidence': f'File content indicator found: {indicator}',
                                    'description': 'LFI allows reading local files on the server',
                                    'remediation': 'Validate and sanitize file paths, use whitelist, avoid direct file access'
                                })
                                break
                
                except Exception as e:
                    logger.debug(f"Error testing LFI on {url}: {e}")
        
        return vulnerabilities
    
    def _check_rfi(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for Remote File Inclusion vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        # RFI test payloads (using safe external resources for testing)
        if not payloads:
            payloads = [
                'http://example.com/test.txt',
                'https://example.com/test.php',
                '//example.com/test.txt'
            ]
        
        for param_name in params.keys():
            for payload in payloads[:3]:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if response:
                        # Check for indicators of remote file inclusion
                        if 'example' in response.text.lower() or payload in response.text:
                            vulnerabilities.append({
                                'type': 'Remote File Inclusion (RFI)',
                                'severity': 'critical',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'evidence': 'Remote file content appears in response',
                                'description': 'RFI allows including remote files, potentially leading to RCE',
                                'remediation': 'Disable allow_url_include, validate and sanitize file paths, use whitelist'
                            })
                            break
                
                except Exception as e:
                    logger.debug(f"Error testing RFI on {url}: {e}")
        
        return vulnerabilities
    
    def _check_ssti(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for Server-Side Template Injection vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        # SSTI test payloads
        if not payloads:
            payloads = [
                '{{7*7}}',
                '${7*7}',
                '<%= 7*7 %>',
                '{{config}}',
                '{{config.items()}}',
                '{7*7}',
                '${{7*7}}',
                '#{7*7}'
            ]
        
        for param_name in params.keys():
            for payload in payloads[:5]:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if response:
                        # Check for mathematical evaluation (7*7 = 49)
                        if '49' in response.text or 'config' in response.text:
                            if payload.replace('7*7', '49') in response.text or 'config' in payload.lower():
                                vulnerabilities.append({
                                    'type': 'Server-Side Template Injection (SSTI)',
                                    'severity': 'critical',
                                    'url': url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'evidence': 'Template expression evaluated in response',
                                    'description': 'SSTI allows arbitrary code execution on the server',
                                    'remediation': 'Use sandboxed templates, validate user input, avoid user-controlled template content'
                                })
                                break
                
                except Exception as e:
                    logger.debug(f"Error testing SSTI on {url}: {e}")
        
        return vulnerabilities
    
    def _check_crlf_injection(self, url: str) -> List[Dict]:
        """Check for CRLF Injection vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        # CRLF injection payloads
        payloads = [
            '%0d%0aSet-Cookie:test=crlf',
            '%0d%0aLocation:http://evil.com',
            '%0ASet-Cookie:test=crlf',
            '%0D%0ASet-Cookie:test=crlf',
            '\r\nSet-Cookie:test=crlf'
        ]
        
        for param_name in params.keys():
            for payload in payloads:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if response:
                        # Check if injected header appears in response headers
                        if 'test=crlf' in str(response.headers).lower():
                            vulnerabilities.append({
                                'type': 'CRLF Injection',
                                'severity': 'medium',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'evidence': 'Injected header found in response',
                                'description': 'CRLF injection allows header manipulation and response splitting',
                                'remediation': 'Validate and sanitize user input, remove newline characters'
                            })
                            break
                
                except Exception as e:
                    logger.debug(f"Error testing CRLF injection on {url}: {e}")
        
        return vulnerabilities
    
    def _check_host_header_injection(self, url: str) -> List[Dict]:
        """Check for Host Header Injection vulnerabilities."""
        vulnerabilities = []
        
        evil_hosts = ['evil.com', 'attacker.com', 'test.evil.com']
        
        for evil_host in evil_hosts:
            try:
                response = self.http_client.get(url, headers={'Host': evil_host})
                if response:
                    # Check if evil host appears in response
                    if evil_host in response.text:
                        vulnerabilities.append({
                            'type': 'Host Header Injection',
                            'severity': 'medium',
                            'url': url,
                            'payload': evil_host,
                            'evidence': f'Injected host "{evil_host}" reflected in response',
                            'description': 'Host header injection can lead to cache poisoning, password reset poisoning, and SSRF',
                            'remediation': 'Validate Host header against whitelist, use absolute URLs'
                        })
                        break
            
            except Exception as e:
                logger.debug(f"Error testing host header injection on {url}: {e}")
        
        return vulnerabilities
    
    def _check_ldap_injection(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for LDAP Injection vulnerabilities."""
        vulnerabilities = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return vulnerabilities
        
        # LDAP injection payloads
        if not payloads:
            payloads = [
                '*',
                '*)(&',
                '*)(uid=*',
                'admin)(&(password=*',
                '*)(objectClass=*',
                '*))(|(cn=*'
            ]
        
        # LDAP error indicators
        ldap_errors = [
            'javax.naming.NameNotFoundException',
            'LDAPException',
            'com.sun.jndi.ldap',
            'Search: Bad search filter',
            'Protocol error occurred',
            'Size limit exceeded'
        ]
        
        for param_name in params.keys():
            for payload in payloads[:5]:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = self.http_client.get(test_url)
                    if response:
                        for error in ldap_errors:
                            if error in response.text:
                                vulnerabilities.append({
                                    'type': 'LDAP Injection',
                                    'severity': 'high',
                                    'url': url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'evidence': f'LDAP error detected: {error}',
                                    'description': 'LDAP injection allows manipulation of LDAP queries',
                                    'remediation': 'Use parameterized LDAP queries, validate and sanitize input'
                                })
                                break
                
                except Exception as e:
                    logger.debug(f"Error testing LDAP injection on {url}: {e}")
        
        return vulnerabilities
    
    def _check_xml_injection(self, url: str, payloads: List[str]) -> List[Dict]:
        """Check for XML Injection vulnerabilities."""
        vulnerabilities = []
        
        # XML injection payloads
        if not payloads:
            payloads = [
                '<foo>test</foo>',
                '<?xml version="1.0"?><foo>test</foo>',
                '<test><foo>bar</foo></test>',
                '</foo><injected>test</injected><foo>'
            ]
        
        for payload in payloads[:3]:
            try:
                response = self.http_client.post(
                    url,
                    data=payload,
                    headers={'Content-Type': 'application/xml'}
                )
                
                if response:
                    # Check if injected XML appears in response
                    if 'injected' in response.text or 'test' in response.text:
                        vulnerabilities.append({
                            'type': 'XML Injection',
                            'severity': 'medium',
                            'url': url,
                            'payload': payload,
                            'evidence': 'Injected XML content reflected in response',
                            'description': 'XML injection allows manipulation of XML structure',
                            'remediation': 'Validate and sanitize XML input, use XML schema validation'
                        })
                        break
            
            except Exception as e:
                logger.debug(f"Error testing XML injection on {url}: {e}")
        
        return vulnerabilities
    
    def _check_insecure_deserialization(self, url: str) -> List[Dict]:
        """Check for Insecure Deserialization vulnerabilities."""
        vulnerabilities = []
        
        # Serialization patterns to look for
        serialization_patterns = [
            r'rO0[A-Za-z0-9+/=]+',  # Java serialization (Base64)
            r'__reduce__',           # Python pickle
            r'O:\d+:',               # PHP serialization
            r'AC ED 00 05',          # Java serialization header
        ]
        
        try:
            response = self.http_client.get(url)
            if response:
                # Check cookies and response for serialization patterns
                cookies_str = str(response.cookies)
                response_text = response.text
                
                for pattern in serialization_patterns:
                    if re.search(pattern, cookies_str) or re.search(pattern, response_text):
                        vulnerabilities.append({
                            'type': 'Insecure Deserialization',
                            'severity': 'critical',
                            'url': url,
                            'evidence': f'Serialization pattern detected: {pattern}',
                            'description': 'Insecure deserialization can lead to remote code execution',
                            'remediation': 'Avoid deserializing untrusted data, use safe serialization formats like JSON'
                        })
                        break
        
        except Exception as e:
            logger.debug(f"Error testing insecure deserialization on {url}: {e}")
        
        return vulnerabilities
    
    def _check_authentication_bypass(self, url: str, context: Dict) -> List[Dict]:
        """Check for Authentication Bypass vulnerabilities."""
        vulnerabilities = []
        
        # Authentication bypass techniques
        bypass_techniques = [
            ({'X-Original-URL': '/admin'}, 'X-Original-URL header bypass'),
            ({'X-Rewrite-URL': '/admin'}, 'X-Rewrite-URL header bypass'),
            ({'X-Forwarded-For': '127.0.0.1'}, 'IP whitelist bypass'),
            ({'X-Custom-IP-Authorization': '127.0.0.1'}, 'Custom IP header bypass'),
        ]
        
        for headers, technique in bypass_techniques:
            try:
                response = self.http_client.get(url, headers=headers)
                baseline_response = self.http_client.get(url)
                
                if response and baseline_response:
                    # Check if bypass was successful (different response)
                    if response.status_code != baseline_response.status_code:
                        if response.status_code == 200 and baseline_response.status_code in [401, 403]:
                            vulnerabilities.append({
                                'type': 'Authentication Bypass',
                                'severity': 'critical',
                                'url': url,
                                'evidence': f'Bypass successful using {technique}',
                                'description': 'Authentication can be bypassed using header manipulation',
                                'remediation': 'Implement proper authentication checks, validate all headers'
                            })
            
            except Exception as e:
                logger.debug(f"Error testing authentication bypass on {url}: {e}")
        
        return vulnerabilities
    
    def _check_information_disclosure(self, url: str, context: Dict) -> List[Dict]:
        """Check for Information Disclosure vulnerabilities."""
        vulnerabilities = []
        
        try:
            response = self.http_client.get(url)
            if not response:
                return vulnerabilities
            
            # Patterns indicating information disclosure
            disclosure_patterns = {
                r'(?i)(password|passwd|pwd)\s*[:=]\s*["\']?([^"\'\\s]+)': 'Password in response',
                r'(?i)(api[_-]?key|apikey)\s*[:=]\s*["\']?([^"\'\\s]+)': 'API key in response',
                r'(?i)(secret|token)\s*[:=]\s*["\']?([^"\'\\s]+)': 'Secret/token in response',
                r'mysql_connect\(': 'Database credentials exposed',
                r'(?i)connection\s+string': 'Connection string exposed',
                r'(?i)private\s+key': 'Private key exposed',
                r'-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----': 'Private key in response',
                r'(?i)exception|error|stack\s+trace': 'Stack trace/error details exposed',
            }
            
            for pattern, description in disclosure_patterns.items():
                if re.search(pattern, response.text):
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'high',
                        'url': url,
                        'evidence': description,
                        'description': 'Sensitive information exposed in response',
                        'remediation': 'Remove sensitive data from responses, implement proper error handling'
                    })
        
        except Exception as e:
            logger.debug(f"Error testing information disclosure on {url}: {e}")
        
        return vulnerabilities
    
    def _check_sensitive_data_exposure(self, url: str, context: Dict) -> List[Dict]:
        """Check for Sensitive Data Exposure vulnerabilities."""
        vulnerabilities = []
        
        try:
            response = self.http_client.get(url)
            if not response:
                return vulnerabilities
            
            # Check for sensitive data patterns
            sensitive_patterns = {
                r'\b\d{3}-\d{2}-\d{4}\b': 'SSN pattern detected',
                r'\b\d{16}\b': 'Credit card number pattern detected',
                r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b': 'Email addresses exposed',
                r'\b\d{3}[- ]?\d{3}[- ]?\d{4}\b': 'Phone numbers exposed',
            }
            
            # Check if connection is not secure
            if not url.startswith('https://'):
                vulnerabilities.append({
                    'type': 'Sensitive Data Exposure',
                    'severity': 'medium',
                    'url': url,
                    'evidence': 'Data transmitted over unencrypted connection',
                    'description': 'Sensitive data transmitted without encryption',
                    'remediation': 'Use HTTPS for all sensitive data transmission'
                })
            
            for pattern, description in sensitive_patterns.items():
                matches = re.findall(pattern, response.text)
                if matches:
                    vulnerabilities.append({
                        'type': 'Sensitive Data Exposure',
                        'severity': 'high',
                        'url': url,
                        'evidence': f'{description} - {len(matches)} occurrence(s) found',
                        'description': 'Sensitive data exposed in response',
                        'remediation': 'Mask or remove sensitive data, implement proper data protection'
                    })
        
        except Exception as e:
            logger.debug(f"Error testing sensitive data exposure on {url}: {e}")
        
        return vulnerabilities
    
    def _check_jwt_vulnerabilities(self, url: str, context: Dict) -> List[Dict]:
        """Check for JWT (JSON Web Token) vulnerabilities."""
        vulnerabilities = []
        
        try:
            response = self.http_client.get(url)
            if not response:
                return vulnerabilities
            
            # Check for JWT in headers or cookies
            auth_header = response.headers.get('Authorization', '')
            cookies_str = str(response.cookies)
            
            # JWT pattern: header.payload.signature
            jwt_pattern = r'eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+'
            
            jwt_tokens = re.findall(jwt_pattern, auth_header + ' ' + cookies_str + ' ' + response.text)
            
            if jwt_tokens:
                for token in jwt_tokens[:2]:  # Check first 2 tokens
                    parts = token.split('.')
                    if len(parts) == 3:
                        # Decode header
                        try:
                            import base64
                            import json
                            
                            # Pad base64 string if needed
                            header_padded = parts[0] + '=' * (4 - len(parts[0]) % 4)
                            header = json.loads(base64.urlsafe_b64decode(header_padded))
                            
                            # Check for "none" algorithm
                            if header.get('alg', '').lower() == 'none':
                                vulnerabilities.append({
                                    'type': 'JWT Vulnerability',
                                    'severity': 'critical',
                                    'url': url,
                                    'evidence': 'JWT uses "none" algorithm',
                                    'description': 'JWT with "none" algorithm allows signature bypass',
                                    'remediation': 'Never accept "none" algorithm, use strong signing algorithms'
                                })
                            
                            # Check for weak algorithms
                            if header.get('alg', '').lower() in ['hs256', 'hs384', 'hs512']:
                                vulnerabilities.append({
                                    'type': 'JWT Vulnerability',
                                    'severity': 'medium',
                                    'url': url,
                                    'evidence': f'JWT uses symmetric algorithm: {header.get("alg")}',
                                    'description': 'JWT uses HMAC which may be vulnerable to key confusion attacks',
                                    'remediation': 'Use asymmetric algorithms (RS256, ES256) for better security'
                                })
                        
                        except Exception as e:
                            logger.debug(f"Error decoding JWT: {e}")
        
        except Exception as e:
            logger.debug(f"Error testing JWT vulnerabilities on {url}: {e}")
        
        return vulnerabilities
    
    def _check_broken_authentication(self, url: str, context: Dict) -> List[Dict]:
        """Check for Broken Authentication vulnerabilities."""
        vulnerabilities = []
        
        try:
            response = self.http_client.get(url)
            if not response:
                return vulnerabilities
            
            # Check for weak session management
            cookies = response.cookies
            
            for cookie in cookies:
                # Check if session cookie lacks security flags
                if 'session' in cookie.name.lower() or 'token' in cookie.name.lower():
                    if not cookie.secure:
                        vulnerabilities.append({
                            'type': 'Broken Authentication',
                            'severity': 'high',
                            'url': url,
                            'evidence': f'Session cookie "{cookie.name}" lacks Secure flag',
                            'description': 'Session cookies without Secure flag can be intercepted',
                            'remediation': 'Set Secure flag on all session cookies'
                        })
                    
                    if not cookie.has_nonstandard_attr('HttpOnly'):
                        vulnerabilities.append({
                            'type': 'Broken Authentication',
                            'severity': 'medium',
                            'url': url,
                            'evidence': f'Session cookie "{cookie.name}" lacks HttpOnly flag',
                            'description': 'Session cookies without HttpOnly flag are vulnerable to XSS',
                            'remediation': 'Set HttpOnly flag on all session cookies'
                        })
            
            # Check for predictable session IDs
            if cookies:
                for cookie in cookies:
                    if 'session' in cookie.name.lower():
                        # Check if session ID is numeric or too short
                        if cookie.value.isdigit() or len(cookie.value) < 16:
                            vulnerabilities.append({
                                'type': 'Broken Authentication',
                                'severity': 'critical',
                                'url': url,
                                'evidence': f'Weak session ID detected: {cookie.name}',
                                'description': 'Predictable or weak session IDs can be guessed',
                                'remediation': 'Use strong, random session ID generation'
                            })
        
        except Exception as e:
            logger.debug(f"Error testing broken authentication on {url}: {e}")
        
        return vulnerabilities
    
    def _is_api_endpoint(self, url: str) -> bool:
        """Check if URL appears to be an API endpoint."""
        api_indicators = ['/api/', '/v1/', '/v2/', '/v3/', '/rest/', '/graphql', '.json', '/ws/']
        return any(indicator in url.lower() for indicator in api_indicators)
    
    def _is_upload_endpoint(self, url: str, context: Dict) -> bool:
        """Check if URL appears to be a file upload endpoint."""
        upload_indicators = ['upload', 'file', 'attachment', 'media', 'image', 'document']
        
        # Check URL
        if any(indicator in url.lower() for indicator in upload_indicators):
            return True
        
        # Check for file input fields in forms
        forms = context.get('forms', [])
        for form in forms:
            if 'type="file"' in str(form) or 'input type="file"' in str(form).lower():
                return True
        
        return False
    
    def analyze_anomalies(self, responses: List[Dict]) -> Dict:
        """
        Analyze response patterns for anomalies using ML.
        
        Args:
            responses: List of HTTP responses
            
        Returns:
            Anomaly analysis results
        """
        return self.anomaly_detector.analyze_response_patterns(responses)
